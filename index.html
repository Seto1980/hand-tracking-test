<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="theme-color" content="#1e1e1e">
<title>AIãƒªãƒãƒ“ãƒªã‚«ã‚¦ãƒ³ã‚¿ãƒ¼</title>

<link rel="manifest" href="manifest.json">
<link rel="apple-touch-icon" href="icon.png">

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
<style>
    body { 
        background-color: #1e1e1e; color: #fff; margin: 0; overflow: hidden; font-family: sans-serif; 
        display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh;
        user-select: none; -webkit-user-select: none; touch-action: manipulation;
    }

    /* --- è¨­å®šç”»é¢ --- */
    #settings-overlay {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(30, 30, 30, 0.98); 
        z-index: 10000; 
        display: flex; flex-direction: column; align-items: center; justify-content: center;
        padding: 20px; box-sizing: border-box;
        overflow-y: auto; 
    }
    .setting-group { margin-bottom: 20px; width: 100%; max-width: 400px; }
    .setting-title { font-size: 1.1rem; color: #aaa; margin-bottom: 8px; text-align: center; }
    .btn-group { display: flex; gap: 8px; justify-content: center; flex-wrap: wrap; }
    
    .select-btn {
        padding: 12px 10px; border: 2px solid #555; background: #333; color: #fff;
        border-radius: 15px; cursor: pointer; font-size: 0.9rem; flex: 1; text-align: center; min-width: 80px;
    }
    .select-btn.active { background: #007bff; border-color: #007bff; }
    .btn-sense-low.active { background: #28a745; border-color: #28a745; } 
    .btn-sense-mid.active { background: #007bff; border-color: #007bff; } 
    .btn-sense-high.active { background: #d93025; border-color: #d93025; } 

    input[type="number"] { padding: 10px; border-radius: 10px; border: none; width: 100px; text-align: center; font-size: 1.5rem; }
    
    #start-app-btn {
        padding: 15px 60px; background: #28a745; color: white; border: none;
        border-radius: 30px; font-size: 1.5rem; font-weight: bold; margin-top: 20px; cursor: pointer;
    }

    /* --- ãƒ¡ã‚¤ãƒ³ç”»é¢UI --- */
    #header-panel {
        position: absolute; top: 0; left: 0; width: 100%; z-index: 50;
        background: rgba(0, 0, 0, 0.85); 
        padding: 10px 0;
        display: flex; flex-direction: column; gap: 5px;
        pointer-events: none; 
    }

    .status-row {
        display: flex; justify-content: space-between; align-items: center;
        padding: 0 15px; font-size: 0.9rem; color: #aaa; pointer-events: auto;
    }
    .status-badge { 
        background: #444; padding: 4px 10px; border-radius: 15px; 
        border: 1px solid #666; cursor: pointer; 
    }

    .count-row {
        display: flex; justify-content: space-around; align-items: center;
        padding: 5px 0;
    }
    .count-box { text-align: center; }
    .count-label { font-size: 0.7rem; color: #ccc; }
    .count-val { font-size: 2.5rem; font-weight: bold; line-height: 1; }
    
    #status-message { 
        color: #fff; font-size: 1.4rem; font-weight: bold; 
        background: #333; padding: 10px 20px; border-radius: 10px;
        min-width: 150px; text-align: center; border: 2px solid #555;
    }
    #status-message.ready { color: #aaa; border-color: #aaa; }
    #status-message.action { color: #ff9800; border-color: #ff9800; } 
    #status-message.ok { color: #4caf50; border-color: #4caf50; background: rgba(76, 175, 80, 0.2); }

    #finger-container {
        margin-top: 0; align-self: center; text-align: center;
        background: rgba(255,255,255,0.1); padding: 5px 20px; border-radius: 15px;
    }
    #finger-visualizer {
        font-family: monospace; font-size: 1.6rem; color: #00FF00; letter-spacing: 3px; font-weight: bold;
    }
    #finger-labels {
        font-size: 0.8rem; color: #fff; margin-top: 0px; letter-spacing: 6px;
    }

    #celebration-msg {
        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
        font-size: 3rem; color: gold; font-weight: bold; text-shadow: 0 0 10px red;
        display: none; z-index: 200; text-align: center; width: 100%;
    }

    .container { position: relative; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; background: #000; }
    video, canvas { position: absolute; width: 100%; height: 100%; object-fit: cover; }
    
    #reset-btn {
        position: absolute; bottom: 30px; right: 20px; z-index: 100;
        padding: 12px 25px; background: #555; color: white; border: none; border-radius: 8px; pointer-events: auto; cursor: pointer;
    }
</style>
</head>
<body>

<div id="settings-overlay">
    <h1 style="margin-bottom:15px;">æ‰‹æŒ‡ãƒªãƒè¨­å®š V16.1</h1>
    
    <div class="setting-group">
        <div class="setting-title">1. å‹•ãã®ãƒ‘ã‚¿ãƒ¼ãƒ³</div>
        <div class="btn-group" id="mode-group">
            <div class="select-btn active" data-mode="GRASP">âœŠâœ‹<br>æ¡ã‚‹</div>
            <div class="select-btn" data-mode="FINGER">ğŸ‘ğŸ–<br>æŒ‡æŠ˜ã‚Š</div>
            <div class="select-btn" data-mode="JANKEN">âœŠâœŒğŸ–<br>ã‚¸ãƒ£ãƒ³ã‚±ãƒ³</div>
        </div>
    </div>

    <div class="setting-group">
        <div class="setting-title">2. ç›®æ¨™å›æ•°</div>
        <div class="btn-group" id="count-group">
            <div class="select-btn" data-count="10">10å›</div>
            <div class="select-btn" data-count="50">50å›</div>
            <div class="select-btn" data-count="100">100å›</div>
            <input type="number" id="custom-count" placeholder="è‡ªç”±" min="1">
        </div>
    </div>

    <div class="setting-group">
        <div class="setting-title">3. æ„Ÿåº¦ (ä¼¸å±•ãƒ»å±ˆæ›²)</div>
        <div class="btn-group" id="sensitivity-group">
            <div class="select-btn btn-sense-low" data-sense="LOW">å¼±<br>å³æ ¼</div>
            <div class="select-btn btn-sense-mid active" data-sense="MEDIUM">ä¸­<br>æ¨™æº–</div>
            <div class="select-btn btn-sense-high" data-sense="HIGH">å¼·<br>åå¿œè‰¯</div>
        </div>
        <div style="font-size:0.8rem; color:#888; text-align:center; margin-top:5px;">
            å¼·ï¼šå°‘ã—ã®ä¼¸ã³ãƒ»æ›²ãŒã‚Šã§åå¿œã—ã¾ã™<br>(æ‹˜ç¸®ãŒã‚ã‚‹æ–¹å‘ã‘)
        </div>
    </div>

    <button id="start-app-btn">ã‚¹ã‚¿ãƒ¼ãƒˆ</button>
</div>

<div id="celebration-msg">ã‚¹ã‚´ã‚¤ã§ã™ã­ï¼<br>ç›®æ¨™é”æˆï¼</div>

<div id="header-panel">
    <div class="status-row">
        <div class="status-badge" id="sense-badge" onclick="toggleSensitivity()">æ„Ÿåº¦: ä¸­</div>
        <div class="status-badge" id="hand-badge">æ¤œå‡ºä¸­...</div>
    </div>

    <div class="count-row">
        <div class="count-box">
            <div class="count-label">ç¾åœ¨</div>
            <div class="count-val" id="current-count">0</div>
        </div>
        <div id="status-message" class="ready">æº–å‚™ä¸­</div>
        <div class="count-box">
            <div class="count-label">ç›®æ¨™</div>
            <div class="count-val" id="target-count-display">--</div>
        </div>
    </div>

    <div id="finger-container">
        <div id="finger-visualizer">ãƒ» ãƒ» ãƒ» ãƒ» ãƒ»</div>
        <div id="finger-labels">è¦ª äºº ä¸­ è–¬ å°</div>
    </div>
</div>

<div class="container">
    <video id="inputVideo" playsinline></video>
    <canvas id="outputCanvas"></canvas>
</div>
<button id="reset-btn">è¨­å®šã«æˆ»ã‚‹</button>

<script>
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => navigator.serviceWorker.register('./service-worker.js'));
    }

    let targetCount = 10;
    let currentCount = 0;
    let mode = 'GRASP'; 
    let sensitivity = 'MEDIUM';
    let isCelebrated = false;
    
    let state = "WAITING";
    let fingerLatch = [false, false, false, false, false];
    let prevBentCount = 0;
    let isThumbLeft = true; 
    let lostFrames = 0;
    const LOST_THRESHOLD = 20; 

    const synth = window.speechSynthesis;
    function speak(text, force = false) {
        if (synth.speaking) synth.cancel(); 
        const ut = new SpeechSynthesisUtterance(text);
        ut.lang = 'ja-JP';
        ut.rate = 1.4; 
        synth.speak(ut);
    }

    const settingsOverlay = document.getElementById('settings-overlay');
    const modeBtns = document.querySelectorAll('#mode-group .select-btn');
    const countBtns = document.querySelectorAll('#count-group .select-btn');
    const senseBtns = document.querySelectorAll('#sensitivity-group .select-btn');
    const customCountInput = document.getElementById('custom-count');
    const currentCountDisplay = document.getElementById('current-count');
    const targetCountDisplay = document.getElementById('target-count-display');
    const statusMessage = document.getElementById('status-message');
    const fingerVisualizer = document.getElementById('finger-visualizer');
    const fingerLabels = document.getElementById('finger-labels');
    const celebrationMsg = document.getElementById('celebration-msg');
    const handBadge = document.getElementById('hand-badge');
    const senseBadge = document.getElementById('sense-badge');

    modeBtns.forEach(btn => btn.onclick = () => {
        modeBtns.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        mode = btn.dataset.mode;
    });
    countBtns.forEach(btn => btn.onclick = () => {
        countBtns.forEach(b => b.classList.remove('active'));
        customCountInput.value = '';
        btn.classList.add('active');
        targetCount = parseInt(btn.dataset.count);
    });
    customCountInput.oninput = () => {
        countBtns.forEach(b => b.classList.remove('active'));
        targetCount = parseInt(customCountInput.value) || 10;
    };
    senseBtns.forEach(btn => btn.onclick = () => {
        senseBtns.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        sensitivity = btn.dataset.sense;
    });

    window.toggleSensitivity = function() {
        if(sensitivity === 'MEDIUM') sensitivity = 'HIGH';
        else if(sensitivity === 'HIGH') sensitivity = 'LOW';
        else sensitivity = 'MEDIUM';
        updateSenseBadge();
        speak("æ„Ÿåº¦" + senseBadge.innerText.replace("æ„Ÿåº¦: ",""), true);
    };

    function updateSenseBadge() {
        let sText = "ä¸­";
        if(sensitivity==='LOW') sText="å¼±";
        if(sensitivity==='HIGH') sText="å¼·";
        senseBadge.innerText = `æ„Ÿåº¦: ${sText}`;
    }

    document.getElementById('start-app-btn').onclick = () => {
        settingsOverlay.style.display = 'none';
        currentCount = 0;
        state = "WAITING";
        isCelebrated = false;
        fingerLatch = [false, false, false, false, false];
        prevBentCount = 0;
        celebrationMsg.style.display = 'none';
        currentCountDisplay.innerText = 0;
        targetCountDisplay.innerText = targetCount;
        updateVisualizer([false,false,false,false,false]);
        updateSenseBadge();

        let startMsg = "ã‚¹ã‚¿ãƒ¼ãƒˆ";
        if(mode === 'GRASP') { startMsg = "æ¡ã£ã¦ï¼"; setStatus("æ¡ã£ã¦", "ready"); }
        if(mode === 'FINGER') { startMsg = "ãƒ‘ãƒ¼ã«ã—ã¦"; setStatus("ãƒ‘ãƒ¼ã«ã—ã¦", "ready"); }
        if(mode === 'JANKEN') { startMsg = "æœ€åˆã¯ã‚°ãƒ¼"; setStatus("ã‚°ãƒ¼", "ready"); }
        
        startCamera();
        speak(startMsg, true);
    };
    document.getElementById('reset-btn').onclick = () => location.reload();

    function setStatus(text, type) {
        statusMessage.innerText = text;
        statusMessage.className = "";
        statusMessage.classList.add(type);
    }

    const videoElement = document.getElementById('inputVideo');
    const canvasElement = document.getElementById('outputCanvas');
    const canvasCtx = canvasElement.getContext('2d');
    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
    hands.onResults(onResults);

    function onResults(results) {
        // â˜…å®‰å…¨è£…ç½®: ã‚¨ãƒ©ãƒ¼ã§ç”»é¢ãŒé»’ããªã‚‹ã®ã‚’é˜²ã
        try {
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            
            if (results.image) {
                canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
            }

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                lostFrames = 0; 
                const landmarks = results.multiHandLandmarks[0];
                
                const thumbX = landmarks[4].x;
                const pinkyX = landmarks[20].x;
                isThumbLeft = thumbX < pinkyX; 

                if (isThumbLeft) {
                    fingerLabels.innerText = "è¦ª äºº ä¸­ è–¬ å°";
                    handBadge.innerText = "è¦ªæŒ‡ãŒå·¦";
                } else {
                    fingerLabels.innerText = "å° è–¬ ä¸­ äºº è¦ª";
                    handBadge.innerText = "è¦ªæŒ‡ãŒå³";
                }

                drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
                drawLandmarks(canvasCtx, landmarks, {color: '#FF0000', lineWidth: 1});

                if(currentCount >= targetCount && !isCelebrated) {
                    isCelebrated = true;
                    setStatus("é”æˆï¼", "ok");
                    celebrationMsg.style.display = "block";
                    speak("ã‚¹ã‚´ã‚¤ã§ã™ã­ï¼ç›®æ¨™é”æˆã§ã™ï¼", true);
                    canvasCtx.restore();
                    return;
                }
                if (isCelebrated) { canvasCtx.restore(); return; }

                const bentStatus = getBentStatusV16(landmarks, sensitivity);
                const extendedStatus = getExtendedStatusV16(landmarks, sensitivity);
                
                if (mode === 'FINGER') {
                    processFingerMode(bentStatus);
                } else {
                    updateVisualizer(extendedStatus);
                    if (mode === 'GRASP') processGrasp(extendedStatus);
                    else if (mode === 'JANKEN') processJanken(extendedStatus);
                }
            } else {
                lostFrames++;
                if (lostFrames >= LOST_THRESHOLD) handBadge.innerText = "æ¤œç´¢ä¸­...";
            }
            canvasCtx.restore();
        } catch (e) {
            console.error("Drawing error:", e);
            canvasCtx.restore(); // ã‚¨ãƒ©ãƒ¼ã§ã‚‚å¾©å¸°ã•ã›ã‚‹
        }
    }

    function updateVisualizer(statusArray) {
        let displayArr = [...statusArray];
        if (!isThumbLeft) displayArr.reverse();
        const marks = displayArr.map(isOn => isOn ? "ã€‡" : "ãƒ»").join(" ");
        fingerVisualizer.innerText = marks;
    }

    function getAngle(A, B, C) {
        const v1 = {x: A.x - B.x, y: A.y - B.y, z: A.z - B.z};
        const v2 = {x: C.x - B.x, y: C.y - B.y, z: C.z - B.z};
        const dot = v1.x * v2.x + v1.y * v2.y + (v1.z * v2.z || 0);
        const mag1 = Math.sqrt(v1.x*v1.x + v1.y*v1.y + (v1.z*v1.z || 0));
        const mag2 = Math.sqrt(v2.x*v2.x + v2.y*v2.y + (v2.z*v2.z || 0));
        const angle = Math.acos(Math.min(Math.max(dot / (mag1 * mag2), -1), 1)) * (180 / Math.PI);
        return isNaN(angle) ? 0 : angle;
    }

    // 1. æ›²ã’åˆ¤å®š
    function getBentStatusV16(landmarks, sensitivity) {
        const bent = [false, false, false, false, false];
        const wrist = landmarks[0];
        
        let bendAngleThresh = 140;
        if (sensitivity === 'HIGH') bendAngleThresh = 165; 
        if (sensitivity === 'LOW') bendAngleThresh = 100; 

        const angleThumb = getAngle(landmarks[2], landmarks[3], landmarks[4]);
        bent[0] = angleThumb < bendAngleThresh;

        const fingerTips = [null, 8, 12, 16, 20];
        const fingerMcp = [null, 5, 9, 13, 17];
        for (let i = 1; i <= 4; i++) {
            const pipIdx = i*4 + 2;
            const angle = getAngle(landmarks[pipIdx-1], landmarks[pipIdx], landmarks[pipIdx+1]);
            
            const distTipMcp = Math.hypot(landmarks[fingerTips[i]].x - landmarks[fingerMcp[i]].x, landmarks[fingerTips[i]].y - landmarks[fingerMcp[i]].y);
            const distMcpWrist = Math.hypot(landmarks[fingerMcp[i]].x - wrist.x, landmarks[fingerMcp[i]].y - wrist.y);
            
            let ratio = (sensitivity === 'HIGH') ? 1.2 : (sensitivity === 'LOW' ? 0.8 : 1.0);
            
            bent[i] = (angle < bendAngleThresh) || (distTipMcp < distMcpWrist * ratio);
        }
        return bent;
    }

    // 2. ä¼¸ã³åˆ¤å®š
    function getExtendedStatusV16(landmarks, sensitivity) {
        const extended = [false, false, false, false, false];
        const wrist = landmarks[0];

        // ä¼¸ã°ã—åˆ¤å®šã®é–¾å€¤ã‚’å¤§å¹…ç·©å’Œ (ç‰¹ã«HIGH)
        let extendAngleThresh = 150; 
        if (sensitivity === 'HIGH') extendAngleThresh = 130; // 130åº¦ã‚ã‚Œã°OK
        if (sensitivity === 'LOW') extendAngleThresh = 165;

        const angleThumb = getAngle(landmarks[2], landmarks[3], landmarks[4]);
        extended[0] = angleThumb > extendAngleThresh;

        const fingerTips = [null, 8, 12, 16, 20];
        const fingerMcp = [null, 5, 9, 13, 17];
        for (let i = 1; i <= 4; i++) {
            const pipIdx = i*4 + 2;
            const angle = getAngle(landmarks[pipIdx-1], landmarks[pipIdx], landmarks[pipIdx+1]);
            
            const distTipWrist = Math.hypot(landmarks[fingerTips[i]].x - wrist.x, landmarks[fingerTips[i]].y - wrist.y);
            const distMcpWrist = Math.hypot(landmarks[fingerMcp[i]].x - wrist.x, landmarks[fingerMcp[i]].y - wrist.y);
            
            // ä¼¸ã³æ¯”ç‡ã‚‚ç·©å’Œ
            let ratio = (sensitivity === 'HIGH') ? 1.3 : 1.8; 

            extended[i] = (angle > extendAngleThresh) || (distTipWrist > distMcpWrist * ratio);
        }
        return extended;
    }

    function processFingerMode(bentStatus) {
        const beforeCount = fingerLatch.filter(Boolean).length;
        
        if (stepState === 99) {
            updateVisualizer(fingerLatch);
            const currentBentCount = bentStatus.filter(Boolean).length;
            let resetThreshold = (sensitivity === 'HIGH') ? 1 : 0;

            if (currentBentCount <= resetThreshold) { 
                stepState = 0;
                fingerLatch = [false,false,false,false,false];
                prevBentCount = 0;
                updateVisualizer(fingerLatch);
                setStatus("ã‚¹ã‚¿ãƒ¼ãƒˆ", "ready");
                speak("æ¬¡ã¸", true);
            } else {
                setStatus("ãƒ‘ãƒ¼ã«æˆ»ã—ã¦", "action");
            }
            return;
        }

        const currentBentCount = bentStatus.filter(Boolean).length;
        if (prevBentCount < 2 && currentBentCount === 5) { /* skip */ }
        else {
            for(let i=0; i<5; i++) {
                if (bentStatus[i]) fingerLatch[i] = true;
            }
        }
        prevBentCount = currentBentCount;
        updateVisualizer(fingerLatch);

        const afterCount = fingerLatch.filter(Boolean).length;
        if (afterCount > beforeCount && afterCount < 5) speak(afterCount.toString(), true);
        
        if (afterCount === 0) setStatus("æŒ‡ã‚’æ›²ã’ã¦", "ready");
        else if (afterCount < 5) setStatus("ã‚ã¨ " + (5 - afterCount) + " æœ¬", "action");
        else if (afterCount === 5 && stepState !== 99) {
            speak("5", true);
            setTimeout(() => speak("ã‚»ãƒƒãƒˆå®Œäº†", false), 600); 
            currentCount++;
            currentCountDisplay.innerText = currentCount;
            stepState = 99; 
            setStatus("ãƒ‘ãƒ¼ã«æˆ»ã—ã¦", "ok");
        }
    }

    function processGrasp(extended) {
        const count = extended.filter(Boolean).length;
        let openThresh = (sensitivity === 'HIGH') ? 3 : 4;
        let closeThresh = (sensitivity === 'HIGH') ? 1 : 0;

        if (count <= closeThresh) { 
            if (stepState === 0) { stepState = 1; setStatus("é–‹ã„ã¦ï¼", "action"); }
        } else if (count >= openThresh) { 
            if (stepState === 1) { 
                currentCount++;
                currentCountDisplay.innerText = currentCount;
                speak(currentCount + "å›", true);
                stepState = 0; 
                setStatus("æ¡ã£ã¦", "ready"); 
            }
        }
    }

    function processJanken(extended) {
        const count = extended.filter(Boolean).length;
        const isRock = count <= 1;
        const isPaper = count >= 4;
        const isChoki = extended[1] && extended[2] && !extended[3] && !extended[4];

        let shape = 'UNKNOWN';
        if (isRock) shape = 'ROCK';
        else if (isPaper) shape = 'PAPER';
        else if (isChoki) shape = 'SCISSORS';

        if (state === "WAITING" && shape === 'ROCK') {
            speak("ã‚°ãƒ¼", true); 
            state = "GU_DONE"; 
            setStatus("æ¬¡ã¯ãƒãƒ§ã‚­", "action");
        } 
        else if (state === "GU_DONE" && shape === 'SCISSORS') {
            speak("ãƒãƒ§ã‚­", true); 
            state = "CHOKI_DONE"; 
            setStatus("æœ€å¾Œã¯ãƒ‘ãƒ¼", "action");
        } 
        else if (state === "CHOKI_DONE" && shape === 'PAPER') {
            speak("ãƒ‘ãƒ¼ï¼", true); 
            currentCount++;
            currentCountDisplay.innerText = currentCount;
            state = "COOLDOWN"; 
            setStatus("ã‚°ãƒ¼ã«æˆ»ã—ã¦", "ok");
        } 
        else if (state === "COOLDOWN" && shape === 'ROCK') {
            speak("ã‚°ãƒ¼", true);
            state = "GU_DONE";
            setStatus("æ¬¡ã¯ãƒãƒ§ã‚­", "action");
        }
    }

    async function startCamera() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ 
                video: { facingMode: "environment", width: 1280, height: 720 } 
            });
            videoElement.srcObject = stream;
            videoElement.play();
            videoElement.onloadedmetadata = () => {
                canvasElement.width = videoElement.videoWidth;
                canvasElement.height = videoElement.videoHeight;
                processVideo();
            };
        } catch (err) { alert("ã‚«ãƒ¡ãƒ©ã‚¨ãƒ©ãƒ¼: " + err.name); }
    }

    async function processVideo() {
        await hands.send({image: videoElement});
        requestAnimationFrame(processVideo);
    }
</script>
</body>
</html>
